<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>üêç Snake</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      color: #f0f0f0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 20px;
      color: #00ff88;
      text-shadow: 0 0 15px #00ff88;
    }

    .game-container {
      background: rgba(20, 20, 30, 0.9);
      padding: 30px;
      border-radius: 16px;
      border: 2px solid #00ff88;
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
      text-align: center;
    }

    canvas {
      border: 2px solid #00ff88;
      background: #0a0a0f;
      display: block;
      margin: 20px auto;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
    }

    .controls {
      margin: 20px 0;
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }

    button {
      background: #222;
      border: 2px solid #00ff88;
      border-radius: 8px;
      color: #00ff88;
      font-weight: bold;
      padding: 12px 24px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.3s ease;
    }

    button:hover {
      background: #00ff88;
      color: #222;
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(0, 255, 136, 0.8);
    }

    .info {
      display: flex;
      gap: 40px;
      justify-content: center;
      margin-bottom: 15px;
      font-size: 1.2rem;
    }

    .score, .high-score {
      color: #00ff88;
      font-weight: bold;
    }

    .instructions {
      margin-top: 20px;
      color: #aaa;
      font-size: 0.9rem;
    }

    a.back-link {
      display: inline-block;
      margin-top: 20px;
      color: #00ff88;
      text-decoration: none;
      font-weight: bold;
      transition: color 0.3s ease;
    }

    a.back-link:hover {
      color: #fff;
      text-shadow: 0 0 10px #00ff88;
    }

    .game-over {
      color: #ff4444;
      font-size: 1.5rem;
      font-weight: bold;
      margin: 15px 0;
      text-shadow: 0 0 10px #ff4444;
    }
  </style>
</head>
<body>

  <h1>üêç Snake</h1>

  <div class="game-container">
    <div class="info">
      <div>Score: <span class="score" id="score">0</span></div>
      <div>Best: <span class="high-score" id="high-score">0</span></div>
    </div>

    <canvas id="gameCanvas" width="400" height="400"></canvas>

    <div id="game-over" class="game-over" style="display:none;">Game Over!</div>

    <div class="controls">
      <button id="pause-btn">Pause</button>
      <button id="restart-btn">Restart</button>
    </div>

    <div class="instructions">
      <p>üéÆ Controls: Arrow keys or WASD | üçé Eat food and grow | ‚ö†Ô∏è Don't hit yourself or wall!</p>
    </div>

    <a href="og_gamezz_portal.html" class="back-link">‚Üê Back to portal</a>
  </div>

  <script src="coin-system.js"></script>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('high-score');
    const gameOverEl = document.getElementById('game-over');
    const pauseBtn = document.getElementById('pause-btn');
    const restartBtn = document.getElementById('restart-btn');

    const GRID_SIZE = 20;
    const TILE_COUNT = canvas.width / GRID_SIZE;
    const INITIAL_SPEED = 100;

    let snake = [{ x: 10, y: 10 }];
    let food = { x: 15, y: 15 };
    let dx = 1;
    let dy = 0;
    let score = 0;
    let highScore = localStorage.getItem('snakeHighScore') || 0;
    let gameRunning = false;
    let gamePaused = false;
    let gameInterval = null;

    highScoreEl.textContent = highScore;

    function drawGame() {
      // Clear canvas
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw grid pattern
      ctx.strokeStyle = '#1a1a2e';
      ctx.lineWidth = 1;
      for (let i = 0; i < TILE_COUNT; i++) {
        for (let j = 0; j < TILE_COUNT; j++) {
          ctx.strokeRect(i * GRID_SIZE, j * GRID_SIZE, GRID_SIZE, GRID_SIZE);
        }
      }

      // Draw snake with improved graphics
      snake.forEach((segment, index) => {
        const x = segment.x * GRID_SIZE;
        const y = segment.y * GRID_SIZE;
        
        if (index === 0) {
          // Head - smƒõr urƒçuje smƒõr hlavy
          ctx.fillStyle = '#00ff88';
          ctx.fillRect(x + 1, y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
          
          // Gradient efekt na hlavƒõ
          const gradient = ctx.createRadialGradient(
            x + GRID_SIZE/2, y + GRID_SIZE/2, 2,
            x + GRID_SIZE/2, y + GRID_SIZE/2, GRID_SIZE/2
          );
          gradient.addColorStop(0, '#00ff88');
          gradient.addColorStop(1, '#00cc66');
          ctx.fillStyle = gradient;
          ctx.fillRect(x + 1, y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
          
          // Eyes based on direction
          ctx.fillStyle = '#fff';
          if (dx === 1) { // Right
            ctx.fillRect(x + 12, y + 5, 4, 4);
            ctx.fillRect(x + 12, y + 11, 4, 4);
          } else if (dx === -1) { // Left
            ctx.fillRect(x + 4, y + 5, 4, 4);
            ctx.fillRect(x + 4, y + 11, 4, 4);
          } else if (dy === -1) { // Up
            ctx.fillRect(x + 5, y + 4, 4, 4);
            ctx.fillRect(x + 11, y + 4, 4, 4);
          } else if (dy === 1) { // Down
            ctx.fillRect(x + 5, y + 12, 4, 4);
            ctx.fillRect(x + 11, y + 12, 4, 4);
          }
          
          // Eye pupils
          ctx.fillStyle = '#000';
          if (dx === 1) {
            ctx.fillRect(x + 14, y + 6, 2, 2);
            ctx.fillRect(x + 14, y + 12, 2, 2);
          } else if (dx === -1) {
            ctx.fillRect(x + 4, y + 6, 2, 2);
            ctx.fillRect(x + 4, y + 12, 2, 2);
          } else if (dy === -1) {
            ctx.fillRect(x + 6, y + 4, 2, 2);
            ctx.fillRect(x + 12, y + 4, 2, 2);
          } else if (dy === 1) {
            ctx.fillRect(x + 6, y + 14, 2, 2);
            ctx.fillRect(x + 12, y + 14, 2, 2);
          }
          
          // Border highlight
          ctx.strokeStyle = '#00ff88';
          ctx.lineWidth = 2;
          ctx.strokeRect(x + 1, y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
          
        } else {
          // Body segments with gradient
          const bodyGradient = ctx.createRadialGradient(
            x + GRID_SIZE/2, y + GRID_SIZE/2, 2,
            x + GRID_SIZE/2, y + GRID_SIZE/2, GRID_SIZE/2
          );
          bodyGradient.addColorStop(0, '#00cc66');
          bodyGradient.addColorStop(1, '#008844');
          ctx.fillStyle = bodyGradient;
          ctx.fillRect(x + 2, y + 2, GRID_SIZE - 4, GRID_SIZE - 4);
          
          // Body pattern - scales
          ctx.fillStyle = 'rgba(0, 255, 136, 0.2)';
          ctx.fillRect(x + 4, y + 4, GRID_SIZE - 8, GRID_SIZE - 8);
          
          // Border
          ctx.strokeStyle = '#00aa55';
          ctx.lineWidth = 1;
          ctx.strokeRect(x + 2, y + 2, GRID_SIZE - 4, GRID_SIZE - 4);
        }
      });

      // Draw food (apple style)
      const fx = food.x * GRID_SIZE;
      const fy = food.y * GRID_SIZE;
      
      // Apple body
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.arc(fx + GRID_SIZE/2, fy + GRID_SIZE/2 + 1, GRID_SIZE/2 - 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Apple gradient
      const appleGradient = ctx.createRadialGradient(
        fx + GRID_SIZE/2 - 3, fy + GRID_SIZE/2 - 2, 2,
        fx + GRID_SIZE/2, fy + GRID_SIZE/2, GRID_SIZE/2
      );
      appleGradient.addColorStop(0, '#ff6666');
      appleGradient.addColorStop(1, '#cc0000');
      ctx.fillStyle = appleGradient;
      ctx.beginPath();
      ctx.arc(fx + GRID_SIZE/2, fy + GRID_SIZE/2 + 1, GRID_SIZE/2 - 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Apple highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.beginPath();
      ctx.arc(fx + GRID_SIZE/2 - 3, fy + GRID_SIZE/2 - 2, 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Apple stem
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(fx + GRID_SIZE/2, fy + 4);
      ctx.lineTo(fx + GRID_SIZE/2 + 2, fy + 2);
      ctx.stroke();
      
      // Apple leaf
      ctx.fillStyle = '#228B22';
      ctx.beginPath();
      ctx.ellipse(fx + GRID_SIZE/2 + 4, fy + 3, 3, 2, Math.PI/4, 0, Math.PI * 2);
      ctx.fill();
      
      // √övodn√≠ obrazovka p≈ôed startem
      if (!gameRunning) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Hlavn√≠ nadpis "SNAKE"
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 4;
        ctx.font = 'bold 50px Arial';
        ctx.textAlign = 'center';
        ctx.strokeText('SNAKE', canvas.width / 2, canvas.height / 2 - 30);
        ctx.fillText('SNAKE', canvas.width / 2, canvas.height / 2 - 30);
        
        // Podnadpis "PRESS TO START"
        ctx.font = 'bold 22px Arial';
        ctx.lineWidth = 3;
        
        // Blik√°n√≠ textu
        const blink = Math.floor(Date.now() / 500) % 2;
        if (blink) {
          ctx.strokeText('PRESS TO START', canvas.width / 2, canvas.height / 2 + 30);
          ctx.fillText('PRESS TO START', canvas.width / 2, canvas.height / 2 + 30);
        }
      }

      // Paused screen
      if (gamePaused) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 4;
        ctx.font = 'bold 50px Arial';
        ctx.textAlign = 'center';
        ctx.strokeText('PAUSED', canvas.width / 2, canvas.height / 2);
        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
      }
    }

    function moveSnake() {
      if (gamePaused) {
        drawGame(); // P≈ôekreslit s PAUSED overlay
        return;
      }

      const head = { x: snake[0].x + dx, y: snake[0].y + dy };

      // Check wall collision
      if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
        endGame();
        return;
      }

      // Check self collision
      if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        endGame();
        return;
      }

      snake.unshift(head);

      // Check food collision
      if (head.x === food.x && head.y === food.y) {
        score++;
        scoreEl.textContent = score;
        
        // Coin reward: 500 coin≈Ø za ka≈æd√Ωch 15 bod≈Ø
        if (score % 15 === 0 && typeof CoinSystem !== 'undefined') {
          CoinSystem.addCoins(500);
        }
        
        if (score > highScore) {
          highScore = score;
          highScoreEl.textContent = highScore;
          localStorage.setItem('snakeHighScore', highScore);
        }
        placeFood();
      } else {
        snake.pop();
      }

      drawGame();
    }

    function placeFood() {
      do {
        food = {
          x: Math.floor(Math.random() * TILE_COUNT),
          y: Math.floor(Math.random() * TILE_COUNT)
        };
      } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
    }

    function startGame() {
      if (gameRunning) return;
      
      snake = [{ x: 10, y: 10 }];
      dx = 1;
      dy = 0;
      score = 0;
      scoreEl.textContent = score;
      gamePaused = false;
      gameRunning = true;
      gameOverEl.style.display = 'none';
      
      placeFood();
      drawGame();
      
      gameInterval = setInterval(moveSnake, INITIAL_SPEED);
      
      pauseBtn.disabled = false;
    }

    function pauseGame() {
      if (!gameRunning) return;
      gamePaused = !gamePaused;
      pauseBtn.textContent = gamePaused ? 'Continue' : 'Pause';
      drawGame(); // Redraw with PAUSED overlay
    }

    function endGame() {
      gameRunning = false;
      gamePaused = false;
      clearInterval(gameInterval);
      gameOverEl.style.display = 'block';
      pauseBtn.disabled = true;
      pauseBtn.textContent = 'Pauza';
    }

    function restartGame() {
      // Reset state
      gameRunning = false;
      gamePaused = false;
      clearInterval(gameInterval);
      gameOverEl.style.display = 'none';
      pauseBtn.disabled = true;
      pauseBtn.textContent = 'Pause';
      
      // Reset hry
      snake = [{ x: 10, y: 10 }];
      dx = 1;
      dy = 0;
      score = 0;
      scoreEl.textContent = score;
      
      placeFood();
      drawGame();
      animateStartScreen();
    }

    // Controls
    document.addEventListener('keydown', (e) => {
      // Automatick√Ω start p≈ôi prvn√≠m stisku
      if (!gameRunning && !gamePaused) {
        startGame();
      }
      
      if (!gameRunning || gamePaused) return;
      
      switch(e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          if (dy === 0) { dx = 0; dy = -1; }
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          if (dy === 0) { dx = 0; dy = 1; }
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          if (dx === 0) { dx = -1; dy = 0; }
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          if (dx === 0) { dx = 1; dy = 0; }
          break;
      }
    });

    pauseBtn.addEventListener('click', pauseGame);
    restartBtn.addEventListener('click', restartGame);

    // Initial draw and animation loop for start screen
    placeFood();
    drawGame();
    
    // Animaƒçn√≠ smyƒçka pro blik√°n√≠ textu p≈ôed startem
    function animateStartScreen() {
      if (!gameRunning) {
        drawGame();
        requestAnimationFrame(animateStartScreen);
      }
    }
    animateStartScreen();
  </script>

</body>
</html>
